/* SIE CONFIDENTIAL
PhyreEngine(TM) Package 3.18.0.0
* Copyright (C) 2016 Sony Interactive Entertainment Inc.
* All Rights Reserved.
*/

#include "PhyreShaderPlatform.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Switches. 

// Material switch definitions. These are the material switches this shader exposes.
bool PhyreMaterialSwitches 
< 
string MaterialSwitchNames[] = {"LAYERED_TEXTURE_MODE_OVER_NONE_ENABLED", "MULTIPLE_UVS_ENABLED", "VERTEX_COLOR_ENABLED", "LIGHTING_ENABLED", "TEXTURE_ENABLED","ALPHA_ENABLED", "NORMAL_MAPPING_ENABLED", "WRAP_DIFFUSE_LIGHTING", "SPECULAR_ENABLED", "CASTS_SHADOWS", "RECEIVE_SHADOWS", "DOUBLE_SIDED", "MOTION_BLUR_ENABLED", "GENERATE_LIGHTS", "CEL_ENABLED", "RENDER_AS_LOW_RES", "LIGHTMAP_OCCLUSION"}; 
string MaterialSwitchUiNames[] = {"Layered Textures", "Multiple UVs", "Vertex Color", "Lighting","Texture", "Transparency", "Normal Mapping", "Use Wrap Diffuse Lighting", "Specular", "Casts Shadows", "Receive Shadows", "Render Double Sided","Motion Blur", "Generate Lights", "Cel Shading", "Render at Lower Res", "Lightmap Occlusion"}; 
string MaterialSwitchDefaultValues[] = {"", "", "", "", "", "", "", "", "", "", "1", "", "", "", "", "", ""};
>;

#include "PhyreSceneWideParameters.h"
#include "PhyreDefaultShaderSharedCode.h"

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Global shader parameters.
#ifdef ALPHA_ENABLED
half AlphaThreshold : ALPHATHRESHOLD <float UIMin = 0.0; float UIMax = 1.0; string UIName = "Alpha Threshold"; string UILabel = "The alpha threshold.";> = 0.0;	// The alpha threshold.
#endif //! ALPHA_ENABLED

half SoftDepthScale <float UIMin = 0.0001; float UIMax = 1.0; string UIName = "Soft Depth Scale"; string UILabel = "The scale for difference in depth between the particle and scene when softening particles.";> = 0.9f;

// Convert a depth value from post projection space to view space. 
float ConvertDepth(float depth)
{				
#ifdef ORTHO_CAMERA
	float viewSpaceZ = -(depth * scene.cameraFarMinusNear + scene.cameraNearFar.x);
#else //! ORTHO_CAMERA
	float viewSpaceZ = -(scene.cameraNearTimesFar / (depth * scene.cameraFarMinusNear - scene.cameraNearFar.y));
#endif //! ORTHO_CAMERA
	return viewSpaceZ;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Structures
struct ShadowTexturedVSInput
{
#ifdef VERTEX_COLOR_ENABLED
	float4 Color : COLOR0;
#endif //! VERTEX_COLOR_ENABLED
#ifdef SKINNING_ENABLED
	float3 SkinnableVertex : POSITION;
#else //! SKINNING_ENABLED
	float4 Position	: POSITION;
#endif //! SKINNING_ENABLED
#ifdef USE_UVS
	float2 Uv	: TEXCOORD0;
#endif // USE_UVS
#ifdef SKINNING_ENABLED
	float4 SkinIndices : COLOR0;
	float4 SkinWeights : TEXCOORD2;
#endif //! SKINNING_ENABLED
#ifdef MULTIPLE_UVS_ENABLED
	float2 Uv1	: TEXCOORD3;
#endif //! MULTIPLE_UVS_ENABLED
};

struct ShadowTexturedVSOutput
{
#ifdef VERTEX_COLOR_ENABLED
	float4 Color : COLOR0;
#endif //! VERTEX_COLOR_ENABLED
	float4 Position	: POSITION;	
	float2 Uv	: TEXCOORD0;
#ifdef MULTIPLE_UVS_ENABLED
	float2 Uv1	: TEXCOORD1;
#endif //! MULTIPLE_UVS_ENABLED
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Vertex shaders

// Default shadow vertex shader.
ShadowTexturedVSOutput ShadowTexturedVS(ShadowTexturedVSInput IN)
{
	ShadowTexturedVSOutput Out = (ShadowTexturedVSOutput)0;	
#ifdef SKINNING_ENABLED
	float3 position = IN.SkinnableVertex.xyz;
	UNNORMALIZE_SKININDICES(IN.SkinIndices);
	EvaluateSkinPosition4Bones(position.xyz, IN.SkinWeights, IN.SkinIndices, BoneTransforms);
	Out.Position = mul(scene.ViewProjection, float4(position.xyz,1));	
#else //! SKINNING_ENABLED
	float3 position = IN.Position.xyz;
	Out.Position = mul(WorldViewProjection, float4(position.xyz,1));
#endif //! SKINNING_ENABLED
#ifdef USE_UVS
	Out.Uv = IN.Uv;
#else // USE_UVS
	Out.Uv = 0.0f;
#endif // USE_UVS
#ifdef VERTEX_COLOR_ENABLED
	Out.Color = IN.Color;
#endif //! VERTEX_COLOR_ENABLED
	return Out;
} 

 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Fragment shaders.

// Forward render fragment shader
float4 ForwardRenderFP(DefaultPSForwardRenderInput In) : FRAG_OUTPUT_COLOR0
{
#ifdef VERTEX_COLOR_ENABLED
	half4 shadingResult = In.Color * MaterialColour;
#else //! VERTEX_COLOR_ENABLED
	half4 shadingResult = MaterialColour;
#endif //! VERTEX_COLOR_ENABLED

#ifdef TEXTURE_ENABLED
	half4 texValue = h4tex2D(TextureSampler, In.Uv);
	shadingResult *= texValue;

#ifdef MULTIPLE_UVS_ENABLED
#ifdef LAYERED_TEXTURE_MODE_OVER_NONE_ENABLED
	half4 tex2 = h4tex2D(TextureSampler1, In.Uv1);
	float3 fc = shadingResult.xyz;
	float  fa = shadingResult.w;
	float3 bc = tex2.xyz;
	float  ba = tex2.w;
	shadingResult.xyz = fc * fa + (bc * (1.0f - fa));
	shadingResult.w = 1.0f - ((1.0f - ba) * (1.0f - fa));
#endif //! LAYERED_TEXTURE_MODE_OVER_NONE_ENABLED
#endif //! MULTIPLE_UVS_ENABLED

#endif //! TEXTURE_ENABLED

#ifdef USE_LIGHTING
	// Read the normal here before any LOD clip, to keep the normal map texture read non-dependent on PlayStation(R)Vita.
	half3 normal = EvaluateNormal(In);
#endif //! USE_LIGHTING

	// Do alpha test and screendoor LOD Blend early.
#ifdef ALPHA_ENABLED
	clip(shadingResult.w - AlphaThreshold);
#endif //! ALPHA_ENABLED

#ifdef LOD_BLEND
	clip(GetLODDitherValue(GET_LOD_FRAGMENT_UV(In.ScreenPosition)));
#endif //! LOD_BLEND

#ifdef LIGHTMAPPING

	#ifdef MULTIPLE_UVS_ENABLED
		float2 lightmapUV = In.Uv1;
	#else //! MULTIPLE_UVS_ENABLED
		float2 lightmapUV = In.Uv;
	#endif //! MULTIPLE_UVS_ENABLED

	lightmapUV = lightmapUV * LightmapUVScaleOffset.xy + LightmapUVScaleOffset.zw;

	half4 lightmap = h4tex2D(LightmapSampler, lightmapUV);

#endif // LIGHTMAPPING

	// Lighting
#ifdef USE_LIGHTING
	half glossValue = 1;

	#ifdef TEXTURE_ENABLED
		glossValue = texValue.w;
	#endif //! TEXTURE_ENABLED

	half3 lightResult = EvaluateLightingDefault(In, In.WorldPositionDepth.xyz, normal, glossValue);

	#ifdef LIGHTMAP_RGB
		lightResult += lightmap.xyz;
	#endif // LIGHTMAP_RGB

	shadingResult *= half4(((lightResult * MaterialDiffuse) + MaterialEmissiveness), 1);

#endif //! USE_LIGHTING

#ifdef LIGHTMAP_RGB
	#ifndef USE_LIGHTING // No dynamic lights but lightmap detail
		float3 lightResult = GlobalAmbientColor.xyz + lightmap.xyz;
		shadingResult *= float4(((lightResult * MaterialDiffuse) + MaterialEmissiveness), 1);
	#endif // USE_LIGHTING
#endif // LIGHTMAP_RGB

#ifdef LIGHTMAP_OCCLUSION
	shadingResult.xyz *= lightmap.w;
#endif // LIGHTMAP_OCCLUSION

#ifdef FOG_ENABLED
	shadingResult.xyz = EvaluateFog(shadingResult.xyz, In.WorldPositionDepth.w);
#endif //! FOG_ENABLED
#ifdef TONE_MAP_ENABLED
	shadingResult = ToneMap(shadingResult.xyz);
#endif //! TONE_MAP_ENABLED

#ifdef CEL_ENABLED
#ifndef USE_LIGHTING
	half3 normal = EvaluateNormal(In);
#endif //! USE_LIGHTING
	half3 eyeToSurface = normalize(scene.EyePosition - In.WorldPositionDepth.xyz);

	shadingResult.xyz = (abs(dot(eyeToSurface, normal)) < CelOutlineThickness) ? CelOutlineColor.xyz : shadingResult.xyz + CalcLightVal(normal);
#endif //! CEL_ENABLED

#ifdef LOW_RES_PARTICLES
	half sceneDepth = abs(ConvertDepth(tex2D(LowResDepthTexture, In.DepthTexCoord.xy).x));
	half particleDepth = In.DepthTexCoord.z;
	half diff = saturate(SoftDepthScale * (sceneDepth - particleDepth));
	shadingResult.w *= diff;
#endif // LOW_RES_PARTICLES

	return shadingResult;
}

// Light pre pass second pass shader. Samples the light prepass buffer.
#ifdef __psp2__
__nativecolor __regformat half4 LightPrepassApplyFP(DefaultPSLightPrepassRenderInput In, __regformat half4 fragColor : FRAGCOLOR)
#else //! __psp2__
float4 LightPrepassApplyFP(DefaultPSLightPrepassRenderInput In) : FRAG_OUTPUT_COLOR0
#endif //! __psp2__
{
#ifdef VERTEX_COLOR_ENABLED
	half4 shadingResult = In.Color;
#else //! VERTEX_COLOR_ENABLED
	half4 shadingResult = MaterialColour;
#endif //! VERTEX_COLOR_ENABLED
#ifdef TEXTURE_ENABLED
	shadingResult *= h4tex2D(TextureSampler, In.Uv);
#ifdef MULTIPLE_UVS_ENABLED
#endif //! MULTIPLE_UVS_ENABLED
#endif //! TEXTURE_ENABLED

#ifdef __psp2__
#ifdef USE_LIGHTING
	shadingResult *= fragColor;
#endif //! USE_LIGHTING
#else //! __psp2__

	// Lighting
#ifdef USE_LIGHTING
#ifdef LIGHTPREPASS_ENABLED
	float2 screenUv = In.ScreenPosition.xy * scene.screenWidthHeightInv;
	half4 lightResult = tex2D(LightPrepassSampler, screenUv);
#else //! LIGHTPREPASS_ENABLED
	half4 lightResult = 1;
#endif //! LIGHTPREPASS_ENABLED
#ifdef SPECULAR_ENABLED
	lightResult.xyz += (half)(lightResult.w * Shininess);
#endif //! SPECULAR_ENABLED
	shadingResult.xyz *= (half3)((lightResult.xyz * MaterialDiffuse) + MaterialEmissiveness);
#endif //! USE_LIGHTING

#ifdef LIGHTMAPPING

#ifdef MULTIPLE_UVS_ENABLED
	half4 lightmap = h4tex2D(LightmapSampler, In.Uv1);
#else //! MULTIPLE_UVS_ENABLED
	half4 lightmap = h4tex2D(LightmapSampler, In.Uv);
#endif //! MULTIPLE_UVS_ENABLED

	shadingResult.xyz *= lightmap.xyz * lightmap.w;

#endif // LIGHTMAPPING

#ifdef FOG_ENABLED
	shadingResult.xyz = EvaluateFog(shadingResult.xyz, In.WorldPositionDepth.w);
#endif //! FOG_ENABLED
#ifdef TONE_MAP_ENABLED
	shadingResult = ToneMap(shadingResult.xyz);
#endif //! TONE_MAP_ENABLED

#endif //! __psp2__

	return shadingResult;
}


// Textured shadow shader.
#ifdef __psp2__
__nativecolor __regformat unsigned char4 ShadowTexturedFP(ShadowTexturedVSOutput IN)
//half4 ShadowTexturedFP(ShadowTexturedVSOutput IN) : FRAG_OUTPUT_COLOR0
#else //! __psp2__
float4 ShadowTexturedFP(ShadowTexturedVSOutput IN) : FRAG_OUTPUT_COLOR0
#endif //! __psp2__
{
#ifdef ALPHA_ENABLED

#ifdef VERTEX_COLOR_ENABLED
	half4 shadingResult = IN.Color;
#else //! VERTEX_COLOR_ENABLED
	half4 shadingResult = MaterialColour;
#endif //! VERTEX_COLOR_ENABLED

#ifdef TEXTURE_ENABLED
	shadingResult *= h4tex2D(TextureSampler, IN.Uv);
#ifdef MULTIPLE_UVS_ENABLED
#endif //! MULTIPLE_UVS_ENABLED
#endif //! TEXTURE_ENABLED

	half alphaValue = shadingResult.w;
	clip(alphaValue - AlphaThreshold);
#endif //! ALPHA_ENABLED
	return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Techniques.

#ifdef LIGHTING_ENABLED
	#define IGNORE_NUM_LIGHTS_IF_NOT_LIGHTING /* Nothing */
#else //! LIGHTING_ENABLED
	// If we're not using lighting then the shader is not dependent on the light count.
	#define IGNORE_NUM_LIGHTS_IF_NOT_LIGHTING "NUM_LIGHTS",
#endif //! LIGHTING_ENABLED

#ifndef ALPHA_ENABLED

technique ForwardRender
<
	string PhyreRenderPass = "Opaque";
	string VpIgnoreContextSwitches[] = {"NUM_LIGHTS", "LOW_RES_PARTICLES"};
	string FpIgnoreContextSwitches[] = {IGNORE_NUM_LIGHTS_IF_NOT_LIGHTING "INSTANCING_ENABLED", "LOW_RES_PARTICLES"};
>
{
	pass pass0
	{
		DepthTestEnable=true;
		DepthFunc = LEqual;
#ifdef ZPREPASS_ENABLED
		DepthMask = false;
#else //! ZPREPASS_ENABLED
		DepthMask = true;	
#endif //! ZPREPASS_ENABLED
		BlendEnable = false;
		ColorMask = bool4(true,true,true,true);
#ifdef DOUBLE_SIDED
		CullFaceEnable = false;
#else //! DOUBLE_SIDED
		CullFaceEnable = true;
#ifndef MAX
		CullFace = back;
#endif //! MAX
#endif //! DOUBLE_SIDED
		VertexProgram = compile vp40 DefaultForwardRenderVS();
		FragmentProgram = compile fp40 ForwardRenderFP();
	}
}

#endif //! ALPHA_ENABLED

#ifdef ALPHA_ENABLED

technique ForwardRenderAlpha
<
#ifdef RENDER_AS_LOW_RES
	string PhyreRenderPass = "LowResParticles";
#else // RENDER_AS_LOW_RES
	string PhyreRenderPass = "Transparent";
#endif // RENDER_AS_LOW_RES
	string VpIgnoreContextSwitches[] = {"NUM_LIGHTS"};
	string FpIgnoreContextSwitches[] = {IGNORE_NUM_LIGHTS_IF_NOT_LIGHTING "INSTANCING_ENABLED"};
>
{
	pass pass0
	{
		DepthTestEnable=true;
		DepthFunc = LEqual;
#ifdef ZPREPASS_ENABLED
		DepthMask = false;
#else //! ZPREPASS_ENABLED
		DepthMask = true;	
#endif //! ZPREPASS_ENABLED

		BlendEnable = true;
#ifdef RENDER_AS_LOW_RES
		BlendFuncSeparate = {srcalpha, oneminussrcalpha, zero, oneminussrcalpha};
#else // RENDER_AS_LOW_RES
		BlendFunc = {srcAlpha,oneMinusSrcAlpha};
#endif // RENDER_AS_LOW_RES

		ColorMask = bool4(true,true,true,true);
#ifdef DOUBLE_SIDED
		CullFaceEnable = false;
#else //! DOUBLE_SIDED
		CullFaceEnable = true;
#ifndef MAX
		CullFace = back;
#endif //! MAX
#endif //! DOUBLE_SIDED
		VertexProgram = compile vp40 DefaultForwardRenderVS();
		FragmentProgram = compile fp40 ForwardRenderFP();
	}
}

#endif //! ALPHA_ENABLED

#ifdef CASTS_SHADOWS

#ifdef ALPHA_ENABLED

technique ShadowTransparent
<
	string PhyreRenderPass = "ShadowTransparent";
	string VpIgnoreContextSwitches[] = {"NUM_LIGHTS", "LOD_BLEND", "LOW_RES_PARTICLES"};
	string FpIgnoreContextSwitches[] = {"NUM_LIGHTS", "INSTANCING_ENABLED", "LOW_RES_PARTICLES"};
>
{
	pass p0
	{
		DepthTestEnable=true;
		DepthMask = true;
		DepthFunc = LEqual;
		BlendEnable = false;
		AlphaTestEnable = false;
		ColorMask = bool4(false,false,false,false);
#ifdef DOUBLE_SIDED
		CullFaceEnable = false;
#else //! DOUBLE_SIDED
		CullFaceEnable = true;
#ifndef MAX
		CullFace = back;
#endif //! MAX
#endif //! DOUBLE_SIDED
		VertexProgram = compile vp40 ShadowTexturedVS();
		FragmentProgram = compile fp40 ShadowTexturedFP();
	}
}

#else //! ALPHA_ENABLED

technique Shadow
<
	string PhyreRenderPass = "Shadow";
	string VpIgnoreContextSwitches[] = {"NUM_LIGHTS", "LOD_BLEND", "LOW_RES_PARTICLES"};
	string FpIgnoreContextSwitches[] = {"NUM_LIGHTS", "LOD_BLEND", "INSTANCING_ENABLED", "LOW_RES_PARTICLES"};
>
{
	pass p0
	{
		DepthTestEnable=true;
		DepthMask = true;
		DepthFunc = LEqual;
		BlendEnable = false;
		AlphaTestEnable = false;
		ColorMask = bool4(false,false,false,false);
#ifdef DOUBLE_SIDED
		CullFaceEnable = false;
#else //! DOUBLE_SIDED
		CullFaceEnable = true;
#ifndef MAX
		CullFace = back;
#endif //! MAX
#endif //! DOUBLE_SIDED
		VertexProgram = compile vp40 DefaultShadowVS();
		FragmentProgram = compile fp40 DefaultShadowFP();
	}
}

#endif //! ALPHA_ENABLED

#endif //! CASTS_SHADOWS

#ifndef ALPHA_ENABLED

technique ZPrePass
<
	string PhyreRenderPass = "ZPrePass";
	string VpIgnoreContextSwitches[] = {"NUM_LIGHTS", "LOD_BLEND", "LOW_RES_PARTICLES"};
	string FpIgnoreContextSwitches[] = {"NUM_LIGHTS", "INSTANCING_ENABLED", "LOW_RES_PARTICLES"};
>
{
	pass p0
	{
		DepthTestEnable=true;
		DepthMask = true;
		DepthFunc = LEqual;
		ColorMask = bool4(false,false,false,false);
#ifdef DOUBLE_SIDED
		CullFaceEnable = false;
#else //! DOUBLE_SIDED
		CullFaceEnable = true;
#ifndef MAX
		CullFace = back;
#endif //! MAX
#endif //! DOUBLE_SIDED
		VertexProgram = compile vp40 DefaultZPrePassVS();
		FragmentProgram = compile fp40 DefaultUnshadedFP();
	}
}

#endif //! ALPHA_ENABLED


#if 0 // Note: These techniques are disabled until future support is added
#ifndef ALPHA_ENABLED

technique LightPrePass
<
	string PhyreRenderPass = "LightPrePass";
	string VpIgnoreContextSwitches[] = {"NUM_LIGHTS", "LOD_BLEND", "LOW_RES_PARTICLES"};
	string FpIgnoreContextSwitches[] = {"NUM_LIGHTS", "INSTANCING_ENABLED", "LOW_RES_PARTICLES"};
>
{
	pass p0
	{
		DepthTestEnable=true;
#ifdef ZPREPASS_ENABLED
		DepthMask = false;
#else //! ZPREPASS_ENABLED
		DepthMask = true;	
#endif //! ZPREPASS_ENABLED
		DepthFunc = LEqual;
		ColorMask = bool4(true,true,true,true);
#ifdef DOUBLE_SIDED
		CullFaceEnable = false;
#else //! DOUBLE_SIDED
		CullFaceEnable = true;
#ifndef MAX
		CullFace = back;
#endif //! MAX
#endif //! DOUBLE_SIDED
		VertexProgram = compile vp40 DefaultForwardRenderVS();
		FragmentProgram = compile fp40 DefaultLightPrepassFP();
	}
}

technique LightPreMaterialPass
<
	string PhyreRenderPass = "LightPrePassMaterial";
	string VpIgnoreContextSwitches[] = {"NUM_LIGHTS", "LOD_BLEND", "LOW_RES_PARTICLES"};
	string FpIgnoreContextSwitches[] = {"NUM_LIGHTS", "INSTANCING_ENABLED", "LOW_RES_PARTICLES"};
>
{
	pass
	{
		DepthTestEnable=true;
		DepthMask = false;
		DepthFunc = LEqual;
		ColorMask = bool4(true,true,true,true);
#ifdef DOUBLE_SIDED
		CullFaceEnable = false;
#else //! DOUBLE_SIDED
		CullFaceEnable = true;
#ifndef MAX
		CullFace = back;
#endif //! MAX
#endif //! DOUBLE_SIDED
		VertexProgram = compile vp40 DefaultForwardRenderVS();
		FragmentProgram = compile fp40 LightPrepassApplyFP();
	}
}


#endif //! ALPHA_ENABLED

#endif //! Disabled techniques

#ifndef ALPHA_ENABLED

// Techniques
technique DeferredRender
<
	string PhyreRenderPass = "DeferredRender";
	string VpIgnoreContextSwitches[] = {"NUM_LIGHTS", "LOD_BLEND", "LOW_RES_PARTICLES"};
	string FpIgnoreContextSwitches[] = {"NUM_LIGHTS", "INSTANCING_ENABLED", "LOW_RES_PARTICLES"};
>
{
	pass
	{
		DepthTestEnable=true;
		DepthFunc = LEqual;
#ifdef ZPREPASS_ENABLED
		DepthMask = false;
#else //! ZPREPASS_ENABLED
		DepthMask = true;	
#endif //! ZPREPASS_ENABLED
		ColorMask = bool4(true,true,true,true);
#ifdef DOUBLE_SIDED
		CullFaceEnable = false;
#else //! DOUBLE_SIDED
		CullFaceEnable = true;
#ifndef MAX
		CullFace = back;
#endif //! MAX
#endif //! DOUBLE_SIDED		
#ifdef MOTION_BLUR_ENABLED
		StencilFunc = {always, 1, 0xff};
#else //! MOTION_BLUR_ENABLED
		StencilFunc = {always, 0, 0xff};
#endif //! MOTION_BLUR_ENABLED
		StencilOp = {replace,keep,replace};

		VertexProgram = compile vp40 DefaultDeferredRenderVS();
		FragmentProgram = compile fp40 DefaultDeferredRenderFP();
	}
}

#endif //! ALPHA_ENABLED
